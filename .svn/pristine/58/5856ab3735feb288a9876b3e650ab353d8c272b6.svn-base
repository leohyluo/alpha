package com.alpha.self.diagnosis.service.impl;

import java.util.List;
import java.util.Map;
import java.util.Optional;

import javax.annotation.Resource;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.stereotype.Service;

import com.alpha.commons.enums.BasicQuestionType;
import com.alpha.commons.util.DateUtils;
import com.alpha.self.diagnosis.mapper.BasicQuestionMapper;
import com.alpha.self.diagnosis.pojo.BasicQuestion;
import com.alpha.self.diagnosis.pojo.vo.BasicAnswerReplyVo;
import com.alpha.self.diagnosis.pojo.vo.BasicQuestionVo;
import com.alpha.self.diagnosis.pojo.vo.IAnswerVo;
import com.alpha.self.diagnosis.pojo.vo.IQuestionVo;
import com.alpha.self.diagnosis.pojo.vo.LiverRenalQuestionVo;
import com.alpha.self.diagnosis.processor.AbstractBasicAnswerProcessor;
import com.alpha.self.diagnosis.processor.BasicAnswerProcessorAdaptor;
import com.alpha.self.diagnosis.service.BasicQuestionService;
import com.alpha.server.rpc.user.pojo.UserInfo;
import com.alpha.user.service.UserInfoService;

@Service
public class BasicQuestionServiceImpl implements BasicQuestionService {
	
	private Logger logger = LoggerFactory.getLogger(getClass());
	
	@Resource
	private BasicQuestionMapper mapper;
	@Resource
	private UserInfoService userInfoService;

	@Override
	public BasicQuestion find(BasicQuestion question) {
		return mapper.find(question);
	}

	@Override
	public BasicQuestion findByQuestionCode(String questionCode) {
		return mapper.findByQuestionCode(questionCode);
	}
	
	@Override
	public List<BasicQuestion> findNext(BasicQuestion question) {
		return mapper.findNext(question);
	}

	//查找下一个基础问题
	@Override
	public IQuestionVo next(Long userId, Integer inType, Long diagnosisId, String questionCode,
			BasicAnswerReplyVo answervo) throws Exception {
		//查出用户基础信息
		UserInfo userInfo = userInfoService.queryByUserId(userId);
		//将用户回答的答案保存至用户信息
		BasicQuestion currentQuestion = this.findByQuestionCode(questionCode);
		if(currentQuestion == null) {
			logger.warn("invalid question code {}", questionCode);
			return null;
		}
		currentQuestion.merge(userInfo, answervo);
		userInfoService.updateUserInfo(userInfo, inType);
		//找出当前问题后的所有问题
		List<BasicQuestion> questionList = this.findNext(currentQuestion);
		//下一问题用户是否已回答过,是则跳过继续找下一个未回答的问题
		//问题是否满足显示条件(年龄、性别等条件),"否"则跳过问题继续找下一个满足显示条件的问题
		Optional<BasicQuestion> optional = questionList.stream().filter(e->notReply(e, userInfo))
				.filter(e->questionMatch(e, userInfo)).findFirst();
		//需返回客户端的问题
		BasicQuestion question = null;
		if(optional.isPresent()) {
			question = optional.get();
		} else {
			return null;
		}
		//根据问题找出对应的答案
		AbstractBasicAnswerProcessor answerProcessor = BasicAnswerProcessorAdaptor.getProcessor(question.getQuestionCode());
		List<IAnswerVo> answervoList = answerProcessor.process(question, userInfo);
		
		//将问题与答案返回客户端
		if(question.getQuestionCode().equals(BasicQuestionType.LIVER_RENAL.getValue())) {
			return new LiverRenalQuestionVo(diagnosisId, question, answervoList, answervoList);
		} else {
			return new BasicQuestionVo(diagnosisId, question, answervoList);
		}
	}

	/**
	 * 问题是否已回答
	 * @param question	问题
	 * @param userInfo	用户信息
	 * @return
	 */
	private Boolean notReply(BasicQuestion question, UserInfo userInfo) {
		BasicQuestionType questionType = BasicQuestionType.findByValue(question.getQuestionCode());
		if(questionType == null) {
			return true;
		}
		Map<BasicQuestionType, Object> map = userInfo.toMap();
		if(!map.containsKey(questionType)) {
			return true;
		}
		Object obj = map.get(questionType);
		if(obj == null) {
			return true;
		}
		return false;
	}
	
	/**
	 * 问题与用户基础信息匹配
	 * @param question
	 * @param userInfo
	 * @return
	 */
	private Boolean questionMatch(BasicQuestion question, UserInfo userInfo) {
		Boolean result = true;
		Integer gender = question.getGender();
		Integer minAge = question.getMinAge();
		Integer maxAge = question.getMaxAge();
		userInfo.getBirth();
		
		if(gender != null) {
			if(gender == userInfo.getGender()) {
				result = true;
			} else {
				return false;
			}
		}
		if(minAge != null && maxAge != null) {
			if(userInfo.getBirth() != null) {
				float age = DateUtils.getAge(userInfo.getBirth());
				if(age > minAge && age < maxAge) {
					result = true;
				} else {
					result = false;
				}
			}
		}
		return result;
	}

}
