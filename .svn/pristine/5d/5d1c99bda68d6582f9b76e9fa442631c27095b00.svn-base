package com.alpha.self.diagnosis.service.impl;

import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Optional;

import javax.annotation.Resource;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Propagation;
import org.springframework.transaction.annotation.Transactional;

import com.alpha.commons.enums.BasicQuestionType;
import com.alpha.commons.util.CollectionUtils;
import com.alpha.commons.util.DateUtils;
import com.alpha.self.diagnosis.mapper.BasicQuestionMapper;
import com.alpha.self.diagnosis.pojo.BasicQuestion;
import com.alpha.self.diagnosis.pojo.vo.BasicAnswerReplyVo;
import com.alpha.self.diagnosis.pojo.vo.BasicQuestionVo;
import com.alpha.self.diagnosis.pojo.vo.IAnswerVo;
import com.alpha.self.diagnosis.pojo.vo.IQuestionVo;
import com.alpha.self.diagnosis.pojo.vo.LiverRenalQuestionVo;
import com.alpha.self.diagnosis.processor.AbstractBasicAnswerProcessor;
import com.alpha.self.diagnosis.processor.BasicAnswerProcessorAdaptor;
import com.alpha.self.diagnosis.processor.IQuestionVoBuilder;
import com.alpha.self.diagnosis.service.BasicQuestionService;
import com.alpha.server.rpc.diagnosis.pojo.UserBasicRecord;
import com.alpha.server.rpc.user.pojo.UserInfo;
import com.alpha.server.rpc.user.pojo.UserMember;
import com.alpha.user.service.UserBasicRecordService;
import com.alpha.user.service.UserInfoService;
import com.alpha.user.service.UserMemberService;

@Service
@Transactional
public class BasicQuestionServiceImpl implements BasicQuestionService {
	
	private Logger logger = LoggerFactory.getLogger(getClass());
	
	@Resource
	private BasicQuestionMapper mapper;
	@Resource
	private UserInfoService userInfoService;
	@Resource
	private UserBasicRecordService userBasicRecordService;
	@Resource
	private UserMemberService userMemberService;

	@Override
	public BasicQuestion find(BasicQuestion question) {
		return mapper.find(question);
	}

	@Override
	public BasicQuestion findByQuestionCode(String questionCode) {
		return mapper.findByQuestionCode(questionCode);
	}
	
	@Override
	public List<BasicQuestion> findNext(BasicQuestion question) {
		return mapper.findNext(question);
	}

	//查找下一个基础问题
	@Override
	@Transactional(readOnly = false, propagation = Propagation.REQUIRED)
	public IQuestionVo next(Long userId, Integer inType, Long diagnosisId, String questionCode,
			BasicAnswerReplyVo answervo) throws Exception {
		//查出当前问题
		BasicQuestion currentQuestion = this.findByQuestionCode(questionCode);
		if(currentQuestion == null) {
			logger.warn("invalid question code {}", questionCode);
			return null;
		}
		//查出用户基础信息
		UserInfo userInfo = getUserInfo(userId, inType, currentQuestion, answervo);
		//将用户回答的答案同步至用户信息
		currentQuestion.merge(userInfo, answervo);
		userInfoService.updateUserInfo(userInfo, inType);
		//找出当前问题后的所有问题
		List<BasicQuestion> questionList = this.findNext(currentQuestion);
		//下一问题用户是否已回答过,是则跳过继续找下一个未回答的问题
		//问题是否满足显示条件(年龄、性别等条件),"否"则跳过问题继续找下一个满足显示条件的问题
		Optional<BasicQuestion> optional = questionList.stream().filter(e->notReply(e, userInfo))
				.filter(e->questionMatch(e, userInfo)).findFirst();
		//需返回客户端的问题
		BasicQuestion question = null;
		if(optional.isPresent()) {
			question = optional.get();
		} else {
			//将userInfo的数据同步至UserBasicRecord
			UserBasicRecord record = userBasicRecordService.findByDiagnosisId(diagnosisId);
			if(record == null) {
				logger.warn("can not found UserBasicRecord by diagnosisId {}", diagnosisId);
				record = new UserBasicRecord();
				record.setUserId(userId);
			}
			record.copyFromUserInfo(userInfo);
			userBasicRecordService.updateUserBasicRecord(record);
			return null;
		}
		//根据问题找出对应的答案
		AbstractBasicAnswerProcessor answerProcessor = BasicAnswerProcessorAdaptor.getProcessor(question.getQuestionCode());
		IQuestionVo questionVo = answerProcessor.build(diagnosisId, question, userInfo);
		return questionVo;
	}
	
	private UserInfo getUserInfo(Long userId, int inType, BasicQuestion currentQuestion, BasicAnswerReplyVo answer) {
		UserInfo userInfo = null;
		String questionCode = currentQuestion.getQuestionCode();
		//当选择他人时新建一个用户
		if("1000".equals(questionCode) && "0".equals(answer.getAnswerValue())) {
			String content = answer.getContent();
			Map<String, Object> userMemberParam = new HashMap<>();
			userMemberParam.put("uesrId", userId);
			userMemberParam.put("memberName", content);
			List<UserMember> userMemberList = userMemberService.find(userMemberParam);
			logger.info("found {} members by userId:{} and memberName:{}", userMemberList.size(), userId, content);
			
			UserMember userMember = null;
			if(CollectionUtils.isNotEmpty(userMemberList)) {
				userMember = userMemberList.get(0);
			}
			
			if(userMember == null) {
				logger.info("could not found userMember");
				userInfo = new UserInfo();
				userInfo.setInType(inType);
				userInfo.setUserName(content);
				userInfoService.create(userInfo);
				logger.info("create userInfo {}", content);
				
				userMember = new UserMember();
				userMember.setUserId(userId);
				userMember.setMemberId(userInfo.getUserId());
				userMember.setMemberName(userInfo.getUserName());
				userMemberService.create(userMember);
				logger.info("create userMember {}", userInfo.getUserName());
			} else {
				Long memberId = userMember.getMemberId();
				userInfo = userInfoService.queryByUserId(memberId);
				if(userInfo == null) {
					logger.warn("not found userInfo by memberId {}", memberId);
				}
			}
		} else {
			userInfo = userInfoService.queryByUserId(userId);
		}
		return userInfo;
	}

	/**
	 * 问题是否已回答
	 * @param question	问题
	 * @param userInfo	用户信息
	 * @return
	 */
	private Boolean notReply(BasicQuestion question, UserInfo userInfo) {
		BasicQuestionType questionType = BasicQuestionType.findByValue(question.getQuestionCode());
		if(questionType == null) {
			return true;
		}
		Map<BasicQuestionType, Object> map = userInfo.toMap();
		if(!map.containsKey(questionType)) {
			return true;
		}
		Object obj = map.get(questionType);
		if(obj == null) {
			return true;
		}
		return false;
	}
	
	/**
	 * 问题与用户基础信息匹配
	 * @param question
	 * @param userInfo
	 * @return
	 */
	private Boolean questionMatch(BasicQuestion question, UserInfo userInfo) {
		Boolean result = true;
		Integer gender = question.getGender();
		Integer minAge = question.getMinAge();
		Integer maxAge = question.getMaxAge();
		userInfo.getBirth();
		
		if(gender != null) {
			if(gender == userInfo.getGender()) {
				result = true;
			} else {
				return false;
			}
		}
		if(minAge != null && maxAge != null) {
			if(userInfo.getBirth() != null) {
				float age = DateUtils.getAge(userInfo.getBirth());
				if(age > minAge && age < maxAge) {
					result = true;
				} else {
					result = false;
				}
			}
		}
		return result;
	}

}
